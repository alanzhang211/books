## 流处理基础
到目前为止，您已经了解了流处理如何解决传统批处理的一些局限性以及它如何支持新的应用程序和体系结构。您还了解了开源流处理空间的演变以及Flink流应用程序的外观。在本章中，您将进入流媒体世界。

本章的目标是介绍流处理的基本概念及其框架的要求。我们希望在阅读完本章后，您将能够评估现代流处理系统的特性。

## 数据流编程介绍
在我们深入研究流处理的基础知识之前，让我们看看数据流编程的背景以及我们将在本书中使用的术语。

### 数据流图
顾名思义，数据流编程就是描述数据如何在操作间流动。数据流程序通常表示为有向图，其中节点称为运算符并表示计算，而边表示数据依赖性。运算符是数据流应用程序的基本功能单元。它们使用来自输入的数据，对它们执行计算，并将数据生成到输出以供进一步处理。没有输入端口的操作算子称为数据源，没有输出端口的操作算子称为数据汇。数据流图必须至少有一个数据源和一个数据接收器。图2-1显示了一个数据流程序，它从输入的推文流中提取和计算主题标签。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-1.png)

像图2-1中的数据流图被称为逻辑图，因为它们传达了计算逻辑的高级视图。

为了执行数据流程序，其逻辑图被转换为物理数据流图，其详细指定程序的执行方式。例如，如果我们使用分布式处理引擎，则每个运营商可能在不同的物理机器上运行多个并行任务。图2-2显示了图2-1逻辑图的物理数据流图。在逻辑数据流图中，节点表示运算符，在物理数据流中，节点是任务。 “Extract hashtags”和“Count”运算符具有两个并行运算符任务，每个运算任务对输入数据的子集执行计算。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-2.png)

### 数据并行和任务并行
你可以以不同方式利用数据流图中的并行性。首先，您可以对输入数据进行分区，并在数据子集上并行执行相同操作的任务。这种类型的并行性称为数据并行性。数据并行是有用的，因为它允许处理大量数据并将计算负载分散到多个计算节点上。其次，您可以让来自不同运操作算子的任务并行执行相同或不同数据的计算。这种并行性称为任务并行性。使用任务并行性，您可以更好地利用群集的计算资源。

### 数据交换策略
数据交换策略定义如何将数据项分配给物理数据流图中的任务。数据交换策略可以由执行引擎根据操作符的语义自动选择，或者由数据流程序员明确强加。在这里，我们简要回顾一些常见的数据交换策略，如图2-3所示。
前向策略将数据从任务发送到接收任务。如果两个任务都位于同一物理机器上（通常由任务调度程序确保），则此交换策略可避免网络通信。
广播策略将每个数据项发送到操作算子的所有并行任务。由于此策略复制数据并涉及网络通信，因此相当昂贵。
基于密钥的策略通过密钥属性对数据进行分区，并保证具有相同密钥的数据项将由同一任务处理。在图2-2中，“Extract hashtags”运算符的输出由键（hashtag）分区，因此count运算符任务可以正确计算每个hashtag的出现次数。
随机策略将数据项统一分配给操作员任务，以便在计算任务之间均匀分配负载。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-3.png)


## 并行流处理
### 数据流操作
流处理引擎通常提供一组内置操作来输入，转换和输出流。这些运算符可以组合成数据流处理图，以实现流应用程序的逻辑。在本节中，我们将介绍最常见的流操作。

操作可以是无状态的或有状态的。无状态操作不保持任何内部状态。也就是说，事件的处理不依赖于过去看到的任何事件，也不保留历史记录。无状态操作易于并行化，因为事件可以彼此独立地处理，也可以是它们到达的顺序。此外，在发生故障的情况下，可以简单地重新启动无状态操作算子并从中断处继续处理。相反，有状态操作算子可以保留关于它们之前收到的事件的信息。此状态可以由传入事件更新，并可用于未来事件的处理逻辑。有状态流处理应用程序在以容错方式并行化和操作方面更具挑战性，因为在出​​现故障时需要对状态进行有效分区并可靠地恢复。您将在本章末尾了解有关有状态流处理，故障情形和一致性的更多信息。

### 数据摄取和数据输出
数据摄取和数据出口操作允许流处理器与外部系统通信。数据摄取是从外部源获取原始数据并将其转换为适合处理的格式的操作。实现数据逻辑输入的操作算子称之为数据源。一个数据源可以从一个TCP套接字，文件，一个kafka的topic或者传感器接口获取数据。数据出口是以适合外部系统消耗的形式产生输出的操作。执行数据出口的操作算子称为数据接收器，例如包括文件，数据库，消息队列和监视接口。

### 转换操作
转换操作是单程操作，可独立处理每个事件。这些操作在另一个之后消耗一个事件，并对事件数据应用一些转换，从而生成新的输出流。转换逻辑可以集成在运算符中，也可以由用户定义的函数提供，如图2-4所示。函数由应用程序员编写并实现自定义计算逻辑。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-4.png)

操作算子可以接收多种输入和处理多种输出流。它们还可以通过将流拆分为多个流或将流合并为单个流来修改数据流图的结构。我们将在第5章讨论Flink中可用的所有操作算子的语义。

### 滚动聚合
滚动聚合是一种例如总和，最小值和最大值聚合，它会针对每个输入事件不断更新。聚合操作是有状态的，并将当前状态与传入事件组合以产生更新的聚合值。请注意，为了能够有效地将当前状态与事件组合并生成单个值，聚合函数必须是关联的和可交换的。否则，操作算子必须存储完整的历史流处理记录。图2-5显示了滚动最小聚合。操作算子保持当前最小值，并相应地为每个传入事件更新它。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-5.png)


### 窗口操作
转换和滚动聚合一次处理一个事件以生成输出事件并可能更新状态。但是，某些操作必须收集并缓冲记录以计算其结果。例如，考虑流连接操作或整体聚合，例如：中值函数。为了在无界流上有效地评估此类操作，你需要限制这些操作维护的数据量。在本节中，我们将讨论提供此服务的窗口操作。

除了具有实用价值之外，窗口还可以在流上启用语义上有趣的查询。你已经看到滚动聚合如何以聚合值编码整个流的历史记录，并为每个事件提供低延迟结果。这适用于某些应用程序，但如果您只对最新数据感兴趣，该怎么办？考虑一个为驾驶员提供实时交通信息的应用程序，以便他们可以避免拥挤的路线。在这种情况下，您想知道在最后几分钟内某个位置是否发生了事故。另一方面，在这种情况下，了解所有发生过的事故可能并不那么有趣。此外，通过将流历史记录缩减为单个聚合，您将丢失有关数据随时间变化的信息。例如，您可能想知道每5分钟有多少车辆穿过一个交叉路口。

窗口操作从无界事件流中不断创建称为存储桶的有限事件集，并让我们对这些有限集执行计算。事件通常根据数据属性或基于时间分配给存储桶。为了正确定义窗口运算符语义，我们需要确定如何将事件分配给存储桶以及窗口产生结果的频率。窗口的行为由一组策略定义。窗口策略决定何时创建新存储桶，将哪些事件分配给哪些存储桶，以及何时评估存储桶的内容。后一个决定是基于触发条件。当满足触发条件时，将桶内容发送到评估函数，该评估函数将计算逻辑应用于桶元素。评估函数可以是总和或最小的聚合，也可以是应用于存储桶的已收集元素的自定义操作。策略可以基于时间（例如，在最后五秒中接收的事件），计数（例如，最后一百个事件）或数据属性。接下来，我们描述常见窗口类型的语义。

翻滚窗口将事件分配到固定大小的非重叠桶中。当窗口边框通过时，所有事件都被发送到评估函数以进行处理。基于计数的翻滚窗口定义在触发评估之前收集的事件数。图2-6显示了一个基于计数的滚动窗口，它将输入流离散化为四个元素的桶。基于时间的翻滚窗口定义了在桶中缓冲事件的时间间隔。图2-7显示了一个基于时间的滚动窗口，它将事件收集到桶中并每10分钟触发一次计算。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-6.png)

滑动窗口将事件分配给固定大小的重叠桶。因此，事件可能属于多个存储桶。我们通过提供滑动窗口的长度和滑动来定义滑动窗口。这个滑动值定义创建新存储桶的时间间隔。图2-8的基于滑动计数的窗口具有四个事件的长度和三个事件的滑动。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-7.png)

会话窗口在常见的真实场景中非常有用，在这些场景中既不能应用翻滚窗口也不能应用滑动窗口。考虑一个分析在线用户行为的应用程序。在此类应用程序中，我们希望将来自同一用户活动或会话期间的事件组合在一起。会话由相邻时间发生的一系列事件组成，然后是一段时间不活动。例如，用户与一系列新闻文章一个接一个的交互可以被认为是会话。由于会话的长度未事先定义，但取决于实际数据，因此在此方案中无法应用翻滚和滑动窗口。相反，我们需要一个窗口操作，在同一个存储桶中分配属于同一会话的事件。会话窗口根据会话间隙值对会话中的事件进行分组，该值定义了考虑关闭会话的不活动时间。图2-9显示了一个会话窗口。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-8.png)

到目前为止，您看到的所有窗口类型都是在整个流上运行的窗口。但实际上，您可能希望将流分区为多个逻辑流并定义并行窗口。例如，如果您正在接收来自不同传感器的测量值，则可能需要在应用窗口计算之前按传感器ID对流进行分组。在并行窗口中，每个分区独立于其他分区应用窗口策略。图2-10显示了一个长度为2的基于并行计数的滚动窗口，该窗口按事件颜色分区。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-9.png)

窗口操作与流处理中的两个主要概念密切相关：时间语义和状态管理。时间可能是流处理的最重要方面。尽管低延迟是流处理的一个有吸引力的特性，但它的真正价值不仅仅是快速分析。现实世界的系统，网络和通信渠道远非完美，流媒体数据通常可能会延迟或无序到达。了解如何在这种条件下提供准确和确定的结果至关重要。更重要的是，在生成事件时处理事件的流应用程序也应该能够以相同的方式处理历史事件，从而实现离线分析甚至时间旅行分析。当然，如果您的系统无法保护状态免于故障，这一切都不重要。到目前为止，您看到的所有窗口类型都需要在生成结果之前缓冲数据。事实上，如果你想在流应用程序中计算任何有趣的东西，即使是简单的计数，你也需要保持状态。考虑到流应用程序可能运行数天，数月甚至数年，您需要确保在故障情况下可以可靠地恢复状态，并且即使事情中断，您的系统也可以保证准确的结果。在本章的其余部分，我们将深入研究数据流处理失败时的时间和状态保证的概念。

### 时间语义
在本节中，我们将介绍时间语义并描述流式传输中不同的时间概念。我们将讨论流处理器如何通过无序事件提供准确的结果，以及如何使用流执行历史事件处理和时间处理。

### 一分钟在流处理中意味着什么
当处理可能无限制的连续到达事件流时，时间成为应用程序的核心。假设您想要连续计算结果，可能每分钟计算一次。在我们的流应用程序中，一分钟真正意味着什么？

考虑一个程序，分析用户玩在线手机游戏时产生的事件。用户按团队组织，应用程序收集团队的活动，并根据团队成员达到游戏目标的速度，在游戏中提供额外生命和升级等奖励。例如，如果团队中的所有用户在一分钟内弹出500个气泡，他们就会获得升级。爱丽丝是一个忠诚的玩家，每天早上上班途中都会玩游戏。问题是，Alice住在柏林并乘坐地铁去上班。众所周知，柏林地铁的移动互联网连接很糟糕。考虑Alice在手机连接到网络并将事件发送到分析应用程序时开始弹出气泡的情况。然后突然火车进入隧道，她的电话断开连接。 Alice继续玩，游戏事件在她的手机中缓冲。当火车离开隧道时，她重新上线，并将待处理的事件发送到应用程序。该应用程序应该做什么？在这种情况下，一分钟的含义是什么？它是否包括Alice离线的时间？图2-11说明了这个问题。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-10.png)

在线游戏是一个简单的场景，展示了操作算子语义应该如何取决于事件实际发生的时间而不是应用程序接收事件的时间。在手机游戏的情况下，后果可能会像Alice和她的团队一样失望，再也不会再玩了。但是还有更多时间关键的应用程序，我们需要保证它们的语义。如果我们只考虑一分钟内收到的数据量，我们的结果会有所不同，具体取决于网络连接的速度或处理速度。相反，真正定义一分钟内事件数量的是数据本身的时间。

### 处理时间
处理时间是正在执行处理流的操作算子的机器上的本地时钟的时间。处理时间窗口包括在一段时间内碰巧到达窗口操作算子的所有事件，如通过其机器的挂钟测量的。如图2-12所示，在Alice的情况下，处理时间窗口将继续计算她的手机断开连接的时间，从而不计算她在此期间的游戏活动。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-11.png)

### 事件时间
事件时间是流中事件实际发生的时间。事件时间基于附加到流事件的时间戳。时间戳通常在事件数据进入处理管道之前存在于事件数据内（例如，事件创建时间）。图2-13显示事件时间窗口可以正确地将事件放在窗口中，反映事情发生的真实情况，甚至虽然有些事件被推迟了。
![](https://github.com/alanzhang211/books/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE/steaming-system/Stream%20Processing%20with%20Apache%20Flink/img/ch02/image-12.png)

事件时间完全将处理速度与结果分离。基于事件时间的操作是可预测的，其结果是确定性的。无论处理流的速度有多快或事件发生的时间，事件时间窗口计算都将产生相同的结果。无论处理流的速度有多快或事件到达操作算子，事件时间窗口计算都将产生相同的结果。

处理延迟事件只是你可以通过事件时间克服的挑战之一。无序数据无处不在的问题也可以用它来解决。考虑一下在线手机游戏的另一个玩家Bob，他碰巧和Alice在同一列火车上。Bob和Alice玩同一个游戏，但有不同的移动提供商。当Alice的手机在隧道内失去连接时，Bob的手机仍保持连接状态并将事件传递给游戏应用程序。

通过依赖事件时间，即使在无序数据的情况下，我们也可以保证结果的正确性。更重要的是，当与可重放流相结合时，时间戳的确定性使您能够快速转发过去。也就是说，您可以重放流并分析历史数据，就好像事件正在实时发生一样。此外，您可以将计算快进到现在，这样一旦您的程序赶上现在发生的事件，它就可以继续使用完全相同的程序逻辑作为实时应用程序。

### 水印
在我们关于事件时间窗口的讨论中，我们忽略了一个非常重要的方面：我们如何决定何时触发事件时间窗口？也就是说，在确定我们已经收到在某个时间点之前发生的所有事件之前，我们需要等待多长时间？我们怎么知道数据会被推迟？鉴于分布式系统的不可预测的现实和可能由外部组件引起的任意延迟，对这些问题没有明确正确的答案。在本节中，我们将了解如何使用水印来配置事件时窗口行为。

水印是一个全局进度指标，表示我们确信不会再有延迟事件到达的时间点。本质上，水印提供逻辑时钟，通知系统当前事件时间。当操作算子接收到具有时间T的水印时，可以假设不会接收到时间戳小于T的其他事件。水印对于事件时间窗口和处理无序事件的操作算子都是必不可少的。一旦接收到水印，就向操作算子发信号通知已经观察到特定时间间隔的所有时间戳并且触发计算或命令接收事件。

水印在结果置信度和延迟之间提供可配置的权衡。热切的水印确保低延迟，但提供较低的置信度。在这种情况下，迟到的事件可能会在水印之后到达，我们应该提供一些代码来处理它们。另一方面，如果水印过于宽松，则你的信心很高，但可能会不必要地增加处理延迟。

在许多实际应用中，系统没有足够的依据来完美地确定水印。在移动游戏示例中，实际上不可能知道用户可能保持断开多长时间;他们可能会穿过隧道，登上飞机，或者再也不玩了。无论水印是用户定义还是自动生成，在存在拖延任务时跟踪分布式系统中的全局进度可能会出现问题。因此，仅仅依靠水印可能并不总是一个好方式。相反，流处理系统提供一些机制来处理可能在水印之后到达的事件是至关重要的。根据应用程序要求，您可能希望忽略此类事件，记录它们或使用它们来更正以前的结果。

### 处理时间与事件时间
与此同时，你可能想知道如果事件时间解决了我们所有的问题，为什么还要为处理时间而烦恼。事实是，在某些情况下，处理时间确实很有用。处理时间窗口引入了尽可能低的延迟。由于您没有考虑延迟事件和无序事件，因此窗口只需缓冲事件并在达到指定的时间长度后立即触发计算。因此，对于速度比准确性更重要的应用，处理时间就派上用场了。另一种情况是，你需要定期实时报告结果，而不管其准确性如何。示例应用程序将是一个实时监控仪表板，它在收到事件聚合时显示它们。最后，处理时间窗口提供了流本身的原始表示，这可能是某些用例的理想属性。例如，您可能有兴趣观察流并计算每秒检测中断的事件数。回顾一下，处理时间提供了低延迟，但结果取决于处理速度，并且不是确定性的。另一方面，事件时间保证确定性结果，并允许您处理迟到或甚至无序的事件。

## 状态和一致性模型
我们现在转向流处理状态的另一个非常重要的方面。 State在数据处理中无处不在。任何非平凡的计算都需要它。为了产生结果，函数在一段时间或事件数量上累积状态（例如，以计算聚合或检测模式）。有状态运算符使用传入事件和内部状态来计算其输出。以一个滚动聚合运算符为例，该运算符输出到目前为止所见的所有事件的当前总和。运算符将总和的当前值保持为其内部状态，并在每次收到新事件时更新它。同样，考虑一个操作员，当操作员在10分钟内检测到“高温”事件并随后发生“冒烟”事件时会发出警报。操作员需要将“高温”事件存储在其内部状态，直到它看到“冒烟”事件或直到10分钟的时间段到期为止。


如果我们考虑使用批处理系统来分析无界数据集的情况，则状态的重要性变得更加明显。在现代流处理器兴起之前，处理无界数据的常用方法是在批处理系统上重复调度小批量传入事件的作业。作业完成后，将结果写入持久存储，并且所有操作算子状态都将丢失。一旦作业计划在下一批次执行，它就无法访问上一个作业的状态。通常通过将状态管理委派给外部系统（例如数据库）来解决此问题。相比之下，在持续运行的流式作业中，状态在各种事件中都是持久的，我们可以将其作为编程模型中的一等公民。当然，我们也可以使用外部系统来管理流状态，即使这种设计选择可能引入额外的延迟。

由于流操作符处理可能无限制的数据，因此应注意不要让内部状态无限增长。为了限制状态数据的规模，操作算子通常会对目前看到的事件进行一些汇总或概要。这样的概要可以是计数，汇总，到目前为止看到的事件的样本，窗口缓冲区，或保留对正在运行的应用程序重要的一些属性的数据结构。

正如您可能想象的那样，支持有状态运算符会带来一些实现挑战：

状态管理
系统需要有效的状态管理，并确保在并发中得到很好的保护。

状态隔离
并行化变得复杂，因为结果取决于状态和传入事件。幸运的是，在许多情况下，您可以通过密钥对状态进行分区，并独立地管理每个分区的状态。例如，如果要处理来自一组传感器的测量流，则可以使用分区操作算子的状态来独立维护每个传感器的状态。

状态恢复
有状态的算子带来的第三个也是最大的挑战是确保在出现故障的情况下可以恢复状态并且结果也是正确的。在下一节中，我们将详细讨论任务失败和结果保证。


### 任务失败
流作业中的操作算子的状态非常有价值，可以防止失败。如果状态在失败期间丢失，则恢复后结果将不正确。流式传输作业运行很长一段时间，因此可能会在几天甚至几个月内收集状态。在故障情况下重新处理所有输入以重现丢失状态将非常昂贵且耗时的。

在本章的开头，您了解了如何将流式程序建模为数据流图。在执行之前，这些被转换为连接的并行任务的物理数据流图，每个任务运行一些操作符逻辑，消耗输入流并为其他任务生成输出流。典型的实际设置可以轻松地在许多物理机器上并行运行数百个这样的任务。在长时间运行的流式作业中，每个任务都可能随时失败。如何确保以透明方式处理此类故障，以便您的流式传输作业能够继续运行？实际上，您希望流处理器不仅在任务失败的情况下继续处理，而且还提供有关结果和操作算子状态的正确性保证。我们将在本节讨论所有这些问题。

### 什么是任务失败
对于输入流中的每个事件，任务是包含一下步骤的处理流程：（1）接收事件，将其存储在本地缓冲器中; （2）可能会更新内部状态; （3）产生输出记录。在这些步骤中任何环节都可能发生故障，系统必须在故障情况下明确定义其行为。如果任务在第一步中失败，事件是否会丢失？如果在更新其内部状态后失败，它会在恢复后再次更新吗？在这些情况下，输出是否具有确定性？
备注我们假设可靠的网络连接，并且没有丢弃或重复的记录，并且所有事件最终都以FIFO顺序传递到它们的目的地。请注意，Flink使用TCP连接，因此可以保证这些要求。我们还假设完美的故障检测器，并且没有任务会故意恶意行事，这意味着所有非故障任务都遵循上述步骤。

在批处理方案中，所有这些问题都得到了解答，因为批处理作业可以从头开始重新启动。因此，不会丢失任何事件，并且状态完全是从头开始构建的。然而，在流媒体世界中，处理故障并不是一个微不足道的问题。流系统通过提供结果保证来定义其在出现故障时的行为。接下来，我们将回顾现代流处理器提供的保证类型以及系统实现这些保证所实现的一些机制。

### 结果保证
在我们描述不同类型的保证之前，我们需要澄清一些在流处理器中讨论任务故障时常常引起混淆的点。在本章的其余部分，当我们讨论“结果保证”时，我们指的是流处理器内部状态的一致性。也就是说，我们关注应用程序代码在从故障中恢复后看到的状态值。请注意，保证应用程序状态的一致性并不能保证其输出的一致性。一旦数据被发送到接收器，除非接收器系统支持事务，否则很难保证结果的正确性。

### 最多一次
任务失败时最简单的事情就是不做任何事情来恢复丢失的状态并重放丢失的事件。最多一次是一个简单的案例，保证每次事件的处理最多一次。换句话说，可以简单地删除事件，并且不做任何事情来确保结果的正确性。这种类型的保证也称为“不保证”，因为即使是丢弃每个事件的系统也可以提供这种保证。没有任何保证听起来像是一个糟糕的想法，但如果你可以接受近似的结果并且所有你关心的是提供尽可能低的延迟可能会很好。

### 至少一次
在大多数现实世界的应用程序中，期望事件不应该丢失。这种类型的保证被称为至少一次，这意味着将处理所有事件，并且有可能多次处理它们中的一些。如果应用程序的正确性仅取决于信息的完整性，则可以接受重复处理。例如，确定是否在输入流中发生特定事件可以用至少一次保证正确地实现。在最坏的情况下，您将多次找到该事件。但是，计算输入流中特定事件发生的次数可能会在至少一次保证下返回错误的结果。

为了确保至少一次结果的正确性，您需要有一种方法来重放事件 - 来自源或来自某个缓冲区。持久性事件日志将所有事件写入持久存储，以便在任务失败时可以重放它们。实现等效功能的另一种方法是使用记录确认。此方法将每个事件存储在缓冲区中，直到事件处理被管道中的所有任务确认，此时可以丢弃该事件。

### 恰好一次
恰好一次是最严格的保证，很难实现。恰好一次意味着不仅没有事件丢失，而且内部状态的更新将仅针对每个事件应用一次。从本质上讲，这个保证意味着我们的应用程序将提供正确的结果，就好像从未发生过失败一样。

恰好一次保证需要至少一次保证，因此再次需要数据重放机制。此外，流处理器需要确保内部状态一致性。也就是说，在恢复之后，它应该知道事件更新是否已经反映在状态上。事务更新是实现此结果的一种方法，但它们可能会产生大量的性能开销。相反，Flink使用轻量级快照机制来实现一次性结果保证。我们在“检查点，保存点和状态恢复”中讨论Flink的faulttolerance算法。

### 端到端的恰好一次
到目前为止，您看到的保证类型依赖于流处理器管理的应用程序的状态。然而，在真实世界的流应用中，除了流处理器之外，将存在至少一个源和一个接收器。端到端保证是指整个数据处理流程中的结果正确性。每个组件都提供自己的保证，整个管道的端到端保证将是每个组件中最薄弱的。值得注意的是，有时你可以通过较弱的保证获得更强的语义。常见的情况是任务执行幂等操作，例如最大值或最小值。在这种情况下，您可以使用至少一次保证实现一次性语义。


## 总结
在本章中，您学习了数据流处理的基础知识。我们研究了数据流编程模型，并了解了流应用程序如何表示为分布式数据流图。接下来，您了解了并行处理无限流的要求，并了解了流应用程序的延迟和吞吐量的重要性。我们介绍了基本的流操作以及如何使用窗口在无界输入数据上计算有意义的结果。您在流处理中学习了时间的含义，并比较了事件时间和处理时间的概念。最后，我们了解了为什么状态在流应用程序中很重要，以及如何防范故障并确保正确的结果。

到目前为止，我们已经考虑了独立于Apache Flink的流概念。在本书的其余部分，我们将看到Flink如何实际实现这些概念，以及如何使用其DataStream API编写使用我们目前已引入的所有功能的应用程序。
